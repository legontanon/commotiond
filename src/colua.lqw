/* vim: set ts=2 expandtab: */
/**
 *       @file  colua.lqw
 *      @brief  a Commontiond API for the Lua programming Language
 *
 *     @author  Luis E. Garcia Ontanon <luis@ontanon.org>
 *
 *   @internal
 *     Created  01/07/2014
 *    Revision  $Id:  $
 *    Compiler  gcc/g++
 *     Company  The Open Technology Institute
 *   Copyright  Copyright (c) 2013, Josh King
 *
 * This file is part of Commotion, Copyright (c) 2013, Josh King
 *
 * Commotion is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * Commotion is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with Commotion.  If not, see <http://www.gnu.org/licenses/>.
 *
 * =====================================================================================
 */

#Module Commotion static

/* the space between # and include disables parsing of the include file by lqw */
# include <sys/socket.h> // AF_INET
# include <math.h> // floor()
# include "config.h"
# include "debug.h"
#include "commotion.h"
#include "obj.h"
#include "list.h"
#include "tree.h"
#include "cmd.h"
#include "msg.h"
#include "iface.h"
#include "id.h"
#include "loop.h"
#include "plugin.h"
#include "process.h"
#include "profile.h"
#include "socket.h"
#include "util.h"


tyepdef struct dummy {int i;} dummy_t;

/* cmd.h */
#Class Cmd co_str8_t

/* commotion.h */
#Class Connection co_obj_t
#Class Request co_obj_t
#Class Response co_obj_t

/* iface.h */
#Class Iface co_iface_t

/* list.h */
#Class List co_obj_t

/* loop.h */
#OwnClass Loop dummy_t
#Class Timer co_obj_t

/* plugin.h */
#Class Plugin co_obj_t

/* process.h */
#Class Process co_process_t
#Class ProcessProf co_process_t

/* profile.h */
#Class Profile co_obj_t

/* socket.h*/
#Class Soket co_socket_t
#Class USocket co_socket_t
#Class Fd co_fd_t

#Class Tree co_tree32_t

#OwnClass Node dummy_t
#OwnClass Debug dummy_t

#Class Str32 co_str32_t
#Class Uint64 co_uint64_t
#Class Int64 co_int64_t

#OwnClass Obj co_obj_t

/****************************************************************/
/*
 *  file globals;
 */
static co_obj_t* nil_obj = NULL;
static const char* err = NULL;

/** from debug.h  */

#OwnFunction Debug.CLEAN_ERRNO
LQW_MODE int Debug__clean_errno(luaState* L) {
    CLEAN_ERRNO();
    return 0;
}

#define DebugWrap(N) LQW_MODE int Debug__#N(luaState* L) { pushS(L,lqw_Fmt(checkS(L,1))); return 1; }

#OwnFunction Debug.ERROR
DebugWrap(ERROR);
#OwnFunction Debug.ERROR
DebugWrap(WARN);
#OwnFunction Debug.INFO
DebugWrap(INFO);

/****************************************************************/
/* Class Obj: the undeclared class for generic co_obj_t* pointers
   a catch all handler of all userdata...
   every pointer that is not a co_obj_t* is to be dealt as lightuserdata
  */

#define isObj(L,idx) (lua_type(L,idx)==LUA_TUSERDATA)
#define checkObj(L, idx) ( isObj(L,idx)?lua_touserdata(L,idx):luaL_checkudata(L,idx,"MustBeAnObject")) )
#define optObj(L,idx,dflt) ( (lua_gettop(L)<idx || isNil(L,idx)) ? dflt : checkObj(L,idx) )

static co_obj_t* toObj(lua_State* L, int idx) {
    co_obj_t* o = NULL;

    switch(lua_type(L,idx)) {
        case LUA_TNUMBER: {
            luaNumber n = lua_tonumber(L,idx);
            WARN("Number arbitrarily converted to float64 %f",n);
            return co_float64_create(n,COLUA_OWNFLAGS);
        }
        case LUA_TBOOLEAN:
            return co_bool_create(lua_toboolean(L,idx),COLUA_OWNFLAGS);
        case LUA_TSTRING: {
            size_t len=0;
            const char * s = toL(L, idx, &len);
            return co_str32_create(s,len,COLUA_OWNFLAGS);
        } 
        case LUA_TUSERDATA:
            return (co_obj_t*) lua_touserdata(L,idx);
        case LUA_TTABLE: {
            Tree* tree  = co_tree32_create();
            for(lua_pushnil(L);lua_next(L,idx);lua_pop(L,1)) {
                size_t ks = 0;
                const char* k = toL(L,-2,&ks);
                Obj* o = toObj(L,-1);
                if (o) {
                    if (co_tree_insert(tree,k,ks,o) == 0) {
                        WARN("toObj: failure inserting table element '%s'",k);
                        //2do handle err   
                    }
                } else {
                    WARN("toObj: table element '%s' cannot be converted to object",k);
                    //2do handle err    
                }
            }
            lua_pop(L,1);
            
            return tree;
        }
        case LUA_TNIL:
            o = co_nil_create(CO_FLAG_LUAGC);
            break;
        case LUA_TFUNCTION:
        case LUA_TTHREAD:
        case LUA_TLIGHTUSERDATA:    
            Warn("Invalid conversion");
            return NULL;
        default:
            Warn("Invalid Lua Type");
            return NULL;
    }
    return o;
}

static co_obj_t* shiftObj(lua_State* L, int idx) {
    co_obj_t* p;
    
    if(!lua_isuserdata(L,idx))
        return NULL;
    
    p = toObj(L,idx);
    lua_remove(L,idx);
    
    return *p;
}

static int gcObj(lua_State* L,int idx) {
    co_obj_t* o = NULL;
    
    if(lua_type(L,idx) == LUA_TUSERDATA) 
        o = lua_touserdata(L,idx);
    else {
        Error()
        return 0;
    }
    
    if ( o && (o->flags & CO_FLAG_LUAGC) ) switch (o->type) {
        case _nil: 
        case _true: 
        case _false: 
        case _float32: 
        case _float64:
        case _uint8:
        case _uint16:
        case _uint32:
        case _int8:
        case _int16:
        case _int32:
        case _bin8:
        case _bin16:
        case _bin32:
        case _str8:
        case _str16:
        case _str32:
        case _list16:
        case _list32:
        case _tree16:
        case _tree32:
        case _int64:
        case _uint64:        
        case _fixext1:
        case fixext2:
        case _fixext4:
        case _fixext8:
        case _fixext16:
        
        case _ext8:
            switch( ((co_ext8_t)o)->_exttype) {
                case _cmd: 
                case _iface: 
                case _plug:
                case _profile:
                case _cbptr:
                case _fd: 
                case _sock:
                case _co_timer:
                case _process:
                case _ptr:
                    co_obj_free(o);
                    return 0;
                default: goto error;
            }
        case _ext16:
        case _ext32:
            co_obj_free(o);
            return 0;

        default: goto error;
    }
    
    error:
    return 0;
}

static int pushObj(lua_State* L, co_obj_t* o) {
#define PUSH_N_DATA(T, L) lua_pushnumber(L,(luaNumber)(((T##L##_t)o)->data))
#define PUSH_C_DATA(T, L) lua_pushlstring(L,(((T##L##_t)o)->len),(((T##L##_t)o)->data))
    
    int len = 0;
    char* data;
    switch (o->type) {
        
        case _nil: lua_pushnil(L); R1;
        case _true: lua_pushbool(L1); R1;
        case _false: lua_pushbool(L,0); R1;

        case _float32: PUSH_N_DATA(float,32); R1;
        case _float64: PUSH_N_DATA(float,64); R1;
        
        case _uint8: PUSH_N_DATA(uint,8); R1;
        case _uint16: PUSH_N_DATA(uint,16); R1;
        case _uint32: PUSH_N_DATA(uint,32); R1;
        
        case _int8: PUSH_N_DATA(int,8); R1;
        case _int16: PUSH_N_DATA(int,16); R1;
        case _int32: PUSH_N_DATA(int,32); R1;

        case _bin8: PUSH_C_DATA(bin, 8); R1;
        case _bin16: PUSH_C_DATA(bin, 16); R1;
        case _bin32: PUSH_C_DATA(bin, 32); R1;
        
        case _str8: PUSH_C_DATA(str, 8); R1;
        
        case _str16: PUSH_C_DATA(str, 16); R1;
        case _str32: PUSH_C_DATA(str, 32); R1;
        
        case _list16:
        case _list32:
            pushList(L,o);
            R1;
        
        case _tree16:
        case _tree32:
            pushTree(L,o);
            R1;
        
        case _int64: push Int64(L,o);
        case _uint64: push Uint64(L,o);        

        case _ext8:
            switch( ((co_ext8_t)o)->_exttype) {
                case _cmd: pushCmd(L,o); R1;
                case _iface: pushIface(L,o); R1;                    
                case _profile: pushProfile(L,o); R1;
                case _fd:  pushFd(L,o); R1;
                case _sock: pushSock(L,o); R1;
                case _co_timer: pushTimer(L,o); R1;
                case _process: pushProcess(L,o); R1;
                case _cbptr:
                case _plug:
                case _ptr:
                default:
                    goto error;
            }
        
        case _ext16:
        case _ext32:
        case _fixext1:
        case fixext2:
        case _fixext4:
        case _fixext8:
        case _fixext16:
        default:
        goto error;
    }
    WARN("Unsupported type (%d)", o->type );
    error:
        R0;
}

void Obj__gcoll(Obj* o) {
    if ( o->flags & COLUA_OWNFLAG ) co_obj_free(o);
}



#Function Str32.create co_str32_create: Str32{_} @ L{input;input_size} X{flags;COLUA_FLAGS;uint8_t}
#Accessor Str32.__tostring RO: L{$data;$_len}
#Accessor Str32.__length RO: N{$_len}
#Function Str32.__concat co_str_cat: Str32{dst} @ Str32{in} Str32{src2} X{dst;co_str_copy(in);Str32*}
#Function Str32.__eq co_str_cmp: B{(_!=0)} @ Str32{a} Str32{b}
#Function Str32.__lt co_str_cmp: B{(_<0)} @ Str32{a} Str32{b}
#Function Str32.__le co_str_cmp: B{(_<=0)} @ Str32{a} Str32{b}
void (*Str32__gcoll)(Str32*) = Obj__gcoll;


static int intThru(int out);
static int intThru(int out) { return out; } // help, optimizer, help!

static const char* strThru(const char* s);
static const char* strThru(const char* out) { return out;}

co_obj_t *co_uint64_create(const uint64_t input, const uint8_t flags);
static Uint64* u64(uint64_t in);

static Uint64* (uint64_t in){ return co_uint64_create(in, COLUA_OWNFLAG); }

#Function Uint64.new_str co_uint64_create: Uint64{_} @ S{in}  X{input;(uint64_t)strtoull(in,NULL,10);uint64_t}
#Function Uint64.new_num co_uint64_create: Uint64{_} @ N{in}  X{input;(uint64_t)floor(in);uint64_t}

#Function Uint64.__add u64: Uint64{_} @ Uint64{a} Uint64{b} X{in;a->data+b->data;uint64_t}
#Function Uint64.__sub u64: Uint64{_} @ Uint64{a} Uint64{b} X{in;a->data-b->data;uint64_t}
#Function Uint64.__mul u64: Uint64{_} @ Uint64{a} Uint64{b} X{in;a->data*b->data;uint64_t}
#Function Uint64.__div u64: Uint64{_} @ Uint64{a} Uint64{b} X{in;a->data/b->data;uint64_t}
#Function Uint64.__mod u64: Uint64{_} @ Uint64{a} Uint64{b} X{in;a->data%b->data;uint64_t}
#Function Uint64.__len intThru: N{_} @ Uint64{a} X{in;floor( log2(a->data) + 1 );int}
#Function Uint64.__eq intThru: B{_} @ Uint64{a} Uint64{b} X{in;a->data==b->data;int}
#Function Uint64.__lt intThru: B{_} @ Uint64{a} Uint64{b} X{in;a->data==b->data;int}
#Function Uint64.__le intThru: B{_} @ Uint64{a} Uint64{b} X{in;a->data==b->data;int}
#Function Uint64.__tostring strThru: S{_} @ Uint64{a} X{out;lwcFmt("%ull",a->data);const char*}
void (*Uint64__gcoll)(Uint64*) = Obj__gcoll;


co_obj_t *co_int64_create(const int64_t input, const int8_t flags);
static    Int64* i64(int64_t out);
static    Int64* (int64_t out){ return co_int64_create(out, COLUA_OWNFLAG); }
#Function Int64.new_str co_int64_create:            Int64{_}       @ S{in}  X{input;(int64_t)strtoll(in,NULL,10);int64_t}
#Function Int64.new_num co_int64_create:            Int64{_}       @ N{in}  X{input;(int64_t)floor(in);int64_t}
#Function Int64.__add i64:               Int64{_} @ Int64{a} Int64{b} X{out;a->data+b->data;uint64_t}
#Function Int64.__sub i64:               Int64{_} @ Int64{a} Int64{b} X{out;a->data-b->data;uint64_t}
#Function Int64.__mul i64:               Int64{_} @ Int64{a} Int64{b} X{out;a->data*b->data;uint64_t}
#Function Int64.__div i64:               Int64{_} @ Int64{a} Int64{b} X{out;a->data/b->data;uint64_t}
#Function Int64.__mod i64:               Int64{_} @ Int64{a} Int64{b} X{out;a->data%b->data;uint64_t}
#Function Int64.__unm i64:               Int64{_} @ Int64{a}          X{out;-(a->data);uint64_t}
#Function Int64.__eq boolOP: B{_}     @  Int64{a}   Int64{b}          X{out;a->data==b->data;int}
#Function Int64.__lt boolOP: B{_}     @  Int64{a}   Int64{b}          X{out;a->data==b->data;int}
#Function Int64.__le boolOP: B{_}     @  Int64{a}   Int64{b}          X{out;a->data==b->data;int}
#Function Int64.__len intThru: N{_}   @  Int64{a}                     X{out;floor( log2(a->data) + 1 );int}
void    (*Int64__gcoll)                 (Int64*)                      = Obj__gcoll;
#Function Int64.__tostring strThru: \
S{_} @    Int64{a}                                                   X{out;lwcFmt("%dll",a->data);const char*}



/** 
 * @brief sets node id using last four bytes of device's MAC address
 * @param mac the MAC address of the devic
 * @param mac_size the size of the MAC address
 */
#Function Node.set_id_from_mac co_id_set_from_mac: @ L{mac,mac_size}
void co_id_set_from_mac(const unsigned char *mac, int mac_size);

/**
 * @brief Converts node id from host byte order to network byte order
 * @param n the node id (4 bytes)
 */
#Function Node.set_id co_id_set_from_int: @ N{n;uint32_t}

/**
 * @brief Returns nodeid
 */
#Function Node.get_id co_id_get: N{_->id} @



/** @fn init
 * @brief initializes API
 */
#Function Node.init co_init: N{_} @

/** @fn shutdown
 * @brief shuts down the API
 */
#Function Node.shutdown co_shutdown: N{_} @


/** @fn Connection.connect(uri)
 * @brief creates a connection to Commotion daemon at the given URI
 * @param uri URI string
 */
#Function Node.connect co_connect: Connection{_} @ L{uri;ulen}

/** @fn Request.create()
 * @brief closes connection to Commotion daemon
 * @param connection context object for active connection
 */
#Function Request.create co_request_create: Request{_} @

/** @fn Request.append
 * @brief appends object to request
 * @param request request object to append to
 * @param object object to append
 */
#Function Request.append co_request_append: N{_} @ Request{request} Obj{object}

/** Request.append_str(request, s)
 * @brief appends string to request
 * @param request request object to append to
 * @param s string to append
 */
#Function Request.append_str co_request_append_str: N{_} @ Request{request} L{s,slen}

/** @fn Request.append_bin(request, s)
 * @brief appends byte array to request
 * @param request request object to append to
 * @param s array to append
 */
#Function Request.append_bin co_request_append_bin: N{_} @ Request{request} L{s,slen}

/** @fn Request.append_int(request, i)
 * @brief appends int to request
 * @param request request object to append to
 * @param i integer to append
 */
#Function Request.append_int co_request_append_int: N{_} @ Request{request} N{i;int}

/**
 * @brief appends unsigned int to request
 * @param request request object to append to
 * @param i integer to append
 */
#Function Request.append_uint co_request_append_uint: N{_} @ Request{request} N{i;const unsigned int}

/** Connection.call(connection,method,request)
 * @brief sense procedure call to daemon
 * @param connection context object for connection
 * @param method method name
 * @param request request object to send
 */
#Function Connection.call co_call: \
    Response{resp} N{_} @ Connection{} L{method,mlen} Request{request} X{resp;*response;Obj*}

/** Response.__index(response, key)
 * @brief retrieve object from response
 * @param response pointer to response object
 * @param key identifier for response element to retrieve
 */
#Function Response.__index co_response_get: Obj{_} @ Response{response} L{key;klen}

/****************************************************************/
/*! @class Cmd
 *  @brief a mechanism for registering and controlling display of commands

/** @fn Cmd.new(name)
 */
#Function Cmd.new(name) co_str8_create: CmdKey{_} @ L{input;input_size}

LQW_MODE const char* cbKeyCmdCB(void* ptr) {
    return lqwFmt("CmdCB:%s",((co_str8_t*)ptr)->data);
}
#CallBack CmdCB{self} co_cb_t 0: Obj{if(output) *output} N{_} @ Cmd{self} List{params}

/** @fn Cmd.register(key,usage,desc,handler)
 * @brief registers a command
 * @param key the key of the command
 * @param usage the usage of the command
 * @param desc the description of command
 * @param handler the callback that handles the command
 */
#Function Cmd.register co_cmd_register: \
    N{_} @ CmdKey{k} L{usage,ulen} L{desc,dlen} CmdCB{handler,name} X{name;k->data;const char*} X{nlen;k->_len;size_t}

/** @fn CmdKey.exec
 * @brief executes a command by running the function linked to in the command struct
 * @param key the name of the command
 * @param output return object of command
 */
#Function Cmd.exec co_cmd_exec: Obj{out} N{_} @ CmdKey{key} Obj{param} X{output;&out;Obj**}

/**
 * @brief returns command usage format
 * @param key command key
 */
#Function Cmd.usage co_cmd_usage: Obj{out} @ CmdKey{key}

/** @fn CmdKey.desc(key)
 * @brief returns command description (what the command does)
 * @param key the name of the command
 */
#Function Cmd.desc co_cmd_desc: Obj{out} @ CmdKey{key}

/**@fn Cmd.hook(key,cb)
 * @brief hooks callback function into a command
 * @param key the name of the command
 * @param cb callback function
 */
#Function Cmd.hook co_cmd_hook: N{_} @ CmdKey{key} CmdCB{cb;key}

/**
 * @brief process all registered commands with given iterator
 * @param iter iterator function reference
 * @param context other parameters passed to iterator
 */
#CallBack CmdIter co_iter_t NULL: Obj{_} @ Cmd{current}
#Function Cmd.process co_cmd_process: N{_} @ CmdIter{iter} X{context;NULL;void*}

#Function Cmd.__gc co_obj_free: @ CmdKey{key}









/****************************************************************/
/*! @class List
 *  @brief Commotion double linked-list implementation
 */

/**
 * @brief return length (number of objects) of given list
 * @param list list object
 */
#Function List.__len co_list_len(list): N{_} @ List{list}
size_t co_list_length(co_obj_t *list);

/**
 * @brief return first element of given list
 * @param list list object
 */
#Funcion List.first co_list_get_first: Obj{_} @ List{list}

/**
 * @brief return last element of given list
 * @param list list object
 */
#Funcion List.last co_list_get_last: Obj{_} @ List{list}

/**
 * @brief returns each element of the list in succesive calls, NULL when done
 * @param list list object
 * @param pointer to a cookie to mantain state, must be NULL on first call
 */
co_obj_t * co_list_foreach(co_obj_t *list, void** state);

/**
 * @brief process list with given iterator function
 * @param list list object to process
 * @param iter iterator function
 * @param context additional arguments to iterator
 */
#CallBack ListIter co_iter_t NULL: Obj{_} @ Obj{current} 
#Function List.__call co_list_parse: Obj{_} @ List{list} ListIter{iter} X{context;NULL}

/**
 * @brief determine if list contains specified item
 * @param list list object to process
 * @param item item to search for
 */
#Function List.contains co_list_contains: B{_} @ List{list} Obj{item}

/**
 * @brief insert new item in list before specified item
 * @param list list object to process
 * @param new_obj item to insert
 * @param this_obj item to insert before
 */
#Function List.insert_before co_list_insert_before: B{_} @ List{list} Obj{new_obj} Obj{this_obj}

/**
 * @brief insert new item in list after specified item
 * @param list list object to process
 * @param new_obj item to insert
 * @param this_obj item to insert after
 */
#Function List.insert_after co_list_insert_after: B{_} @ List{list} Obj{new_obj} Obj{this_obj}

/**
 * @brief insert new item at beginning of list
 * @param list list object to process
 * @param new_obj item to insert
 */
#Function List.prepend co_list_prepend: N{_} @ List{list} Obj{new_obj}

/**
 * @brief insert new item at end of list
 * @param list list object to process
 * @param new_obj item to insert
 */
#Function List.append co_list_prepend: N{_} @ List{list} Obj{new_obj}

/**
 * @brief delete specified item from list
 * @param list list object to process
 * @param item item to delete
 */
#Function List.delete co_list_delete: N{_} @ List{list} Obj{item}

/**
 * @brief return item at specified position in list
 * @param list list object to process
 * @param index number of item to return
 */
#Function List.element co_list_delete: Obj{_} @ List{list} N{index,const unsigned int}

/**
 * @brief dump raw representation of list
 * @param output output buffer
 * @param olen length of output buffer
 * @param list list object to process
 */
#Function List.raw co_list_raw: L{output;_;524288} @ List{list} X{olen;524288;size_t}

/**
 * @brief import list from raw representation
 * @param list target pointer to new list object
 * @param input input buffer
 * @param ilen length of input buffer
 */
#Function List.import co_list_import: List{listo} @ L{input;ilen} X{list;&listo;List**}


/** @method __tostring
 * @brief returns a string representation of the list
 */
#Alias List.__tostring  List.raw





/****************************************************************/
/*! @class Iface 
 * @brief interface handling for the Commotion daemon
 */

/** @fn Iface.create()
 * @brief checks for available interfaces
 */
#Function Iface.create co_ifaces_create: @

/** @fn Iface.shutdown()
 * @brief removes all interfaces
 */
#Function Iface.shutdown co_ifaces_shutdown: @


/** Iface.foreach(iter)
 * @brief invokes cb for each interface
 * @param iter iterator taking the current interface and returning nothing
 */
#Callback IfaceIter co_iface_iter_t: @ Iface{iface} 
#Function Iface.foreach  co_ifaces_foreach: @ IfaceIter{iter} X{ctx;NULL}



/** @fn Iface.remove(iface_name)
 * @brief removes an interface from the list of available interfaces
 * @param iface_name name of interface to be removed
 */
#Function Iface.remove co_iface_remove: N{_} @ S{iface_name}

/** @fn Iface.add(iface_name,family)
 * @brief adds a new interface to the list of interfaces, checks if it is IPv4 and IPv6 capable, and or wireless
 * @param iface_name name of the interface
 * @param family address family of the interface. Must be AF_INET (IPv4) or AF_INET6 (IPv6), which uses host and port number for addressing
 */
#Value Iface.AF_INET AF_INET  
#Value Iface.AF_INET6 AF_INET6
#Function Iface.add co_iface_add: Iface{_} @ S{iface_name} N{family;int}

/** @fn Iface.wpa_connect(iface)
 * @brief connects the commotion interface to wpa supplicant
 * @param iface interface object
 */
#Function Iface.wpa_connect co_iface_wpa_connect: N{_} @ Iface{iface}

/** @fn Iface.wpa_disconnect(iface)
 * @brief turns off wpa supplicant
 * @param iface interface object
 */
#Function Iface.wpa_disconnect co_iface_wpa_connect: N{_} @ Iface{iface}

/** Iface.get_mac(iface)
 * @brief get mac address of inetrface
 * @param iface interface object
 */
#Function Iface.get_mac co_iface_get_mac: L{output;64;_} N{_} @ Iface{iface} X{output_size;6;int}

/**
 * @brief sets ip address and netmask for commotion interface
 * @param iface interface object
 * @param ip_addr ip address for the socket
 * @param netmask netmask for the socket
 */
#Function Iface.set_ip co_iface_set_ip: N{_} @ Iface{iface} S{ip_addr} S{netmask} 

/** @fn Iface.unset_ip(iface)
 * @brief Resets ip address of chosen interface
 * @param iface interface object
 */
#Function Iface.unset_ip co_iface_unset_ip: N{_} @ Iface{iface} 

/** @fn Iface.set_ssid(iface,ssid)
 * @brief sets SSID from profile or uses default
 * @param iface interface object
 * @param ssid desired SSID
 */
#Function Iface.set_ssid co_iface_set_ssid: N{_} @ Iface{iface} S{ssid}

/** @fn Iface.set_bssid(iface,bssid)
 * @brief sets BSSID from profile or uses default
 * @param iface interface object
 * @param bssid desired BSSID
 */
#Function Iface.set_bssid co_iface_set_bssid: N{_} @ Iface{iface} S{bssid}

/** @fn Iface.set_frequency(iface,frequency)
 * @brief sets wireless frequency (eg. channel) from profile or uses default
 * @param iface interface object
 * @param frequency desired frequency
 */
#Function Iface.set_frequency co_iface_set_frequency: N{_} @ Iface{iface} N{frequency}

/** @fn Iface.set_encryption(iface,proto)
 * @brief specifies the wpa encryption protocol
 * @param iface interface object
 * @param proto desired protocol
 */
#Function Iface.set_encryption co_iface_set_encryption: N{_} @ Iface{iface} S{proto}

/** @fn Iface.set_key(iface,key)
 * @brief specifies the wpa encryption key
 * @param iface interface object
 * @param key desired key
 */
#Function Iface.set_key co_iface_set_key: N{_} @ Iface{iface} S{key}

/** @fn Iface.set_mode(iface,mode)
 * @brief specifies the Wi-Fi mode
 * @param iface interface object
 * @param mode desired mode
 */
#Function Iface.set_mode co_iface_set_mode: N{_} @ Iface{iface} S{mode}

/** @fn Iface.set_apscan(iface,value)
 * @brief sets AP_SCAN value
 * @param iface interface object
 * @param value desired value for AP_SCAN
 */
#Function Iface.set_apscan co_iface_set_apscan: N{_} @ Iface{iface} N{value;int}

/** @fn Iface.wireless_enable(iface)
 * @brief enables specified wireless network
 * @param iface interface object
 */
#Function Iface.wireless_enable co_iface_wireless_enable: N{_} @ Iface{iface}

/** @fn Iface.wireless_disable(iface)
 * @brief disables specified wireless network
 * @param iface interface object
 */
#Function Iface.wireless_disable co_iface_wireless_disable: N{_} @ Iface{iface}

/** @fn Iface.set_dns(dnsserver,searchdomain,resolvpath)
 * @brief sets DNS name server and sets search domain
 * @param dnsserver IP addresss of DNS server
 * @param searchdomain desired search domain
 * @param resolvpath filepath to resolv.conf
 */
#Function Iface.set_dns co_set_dns: N{_} @ S{dnsserver} S{searchdomain} S{resolvpath}

/** @fn Iface.gen_ip(base,genmask,id,type)
 * @brief generates an ip table for a commotion interface
 * @param base base address
 * @param genmask genmask
 * @param id the node id
 * @param type whether the device is a gateway (1) or not (0)
 */
#Function Iface.generate_ip co_generate_ip: L{output;_;4096} N{_} @ S{base} S{genmask} N{id;uint32_t} N{type}

/**
 * @brief sets node configuration profile
 * @param iface_name name of interface
 */
#Function Iface.profile co_iface_profile: S{_} @ S{iface_name}

/**
 * @brief retrieves node configuration profile
 * @param iface_name name of interface
 */
#Function Iface.get co_iface_get: Iface{_} @ S{iface_name}




/** @method Iface.status()
  */
#Value Iface.UP 1
#Value Iface.DOWN 0
#Accessor Iface.status RO: N{$status}


/** @method Iface.wpa_id()
  */
#Accessor Iface.wpa_id RO: N{$wpa_id}

/** @method Iface.wireless()
  */
#Accessor Iface.wireless RO: B{$wireless}

// 2do struct ifreq ifr;
// 2do  struct wpa_ctrl *ctrl;


/**
 * @brief sets up the event loop
 */

#Function Loop.create co_loop_create: @

/**
 * @brief closes the event loop
 */
#Function Loop.destroy co_loop_destroy: @

/**
 * @brief starts the event loop, listening for messages on sockets via _co_loop_poll_sockets
 */
#Function Loop.start co_loop_start: @

/**
 * @brief stops the event loop
 */
#Function Loop.stop co_loop_stop: @

/**
 * @brief adds a process to the event loop (for it to listen for)
 * @param proc the process to be added
 */
#Function Loop.add_process co_loop_add_process: N{_} @ Process{proc}
int co_loop_add_process(co_obj_t *proc);

/**
 * @brief removes a process from the event loop
 * @param pid the id of the process to be removed
 */
#Function Loop.remove_process co_loop_remove_process: N{_} @ N{pid;pid_t}

/**
 * @brief adds a new socket to the event loop (for it to listen on)
 * @param new_sock the new socket to be added
 */
#Function Loop.add_socket co_loop_add_socket: N{_} @ Socket{new_sock} X{context;NULL;Obj*}

/**
 * @brief removes a socket from the event loop
 * @param old_sock the socket to be removed
 */
#Function Loop.remove_socket co_loop_remove_socket: N{_} @ Socket{old_sock} X{context;NULL;Obj*}

/**
 * @brief gets a socket that is registered with the event loop
 * @param uri a URI to match against the available sockets
 */
#Function Loop.get_socket co_loop_remove_socket: Socket{_} @ S{uri} X{context;NULL;Obj*}
co_obj_t *co_loop_get_socket(char *uri, co_obj_t *context);

/**
 * @brief schedules a new timer with the event loop
 * @param timer the timer to schedule
 */
#Function Timer.add co_loop_add_timer: N{_} @ Timer{new_timer} X{context;NULL;Obj*}

/**
 * @brief removes a timer from the event loop
 * @param old_timer the timer to remove from list
 */
#Function Timer.remove co_loop_remove_timer: N{_} @ Timer{old_timer} X{context;NULL;Obj*}

/**
 * @brief sets timer to expire in msecs from now
 * @param timer the timer to set
 * @param msecs number of milliseconds
 */
#Function Timer.set co_loop_set_timer: N{_} @ Timer{timer} N{msecs;long} X{context;NULL;Obj*}

/** @constructor Timer.get(name)
 * @brief gets a timer that is registered with the event loop
 * @param name name to be matched against the available timers 
 */
#Function Timer.get co_loop_get_timer: Timer{_} @ S{name} X{context;NULL;Obj*} X{ptr;(void*)name;void*}

/** @constructor Timer.create(name, tv,callback)
 * @brief create a timer
 * @param name name of the timer (used later for Timer.get, save the value in a global so that it is constant)
 * @param tv the timeval (a float that will be converted into it)
 * @param callback the function to be called at expirartion
 */
LqwCbKeyPtr(TimerCB);
#CallBack TimerCb{self} co_cb_t 0: Obj{if(output) *output} N{_} @ Timer{self} List{params}
#Function Timer.create co_timer_create:  Timer{_} @ \
   S{name} N{tv;luaNumber} TimerCb{timer_cb} \
   X{ptr;(void*)lqwPermStr(name);void*}    X{sec;(long)floor(tv);long} \
   X{deadline;??<sec,(long)floor((tv-(double)sec)*1000000.00)??>;struct timeval} 
           
/** @method timer.__tostring()
  */     
#OwnFunction Timer.__tostring  
LQW_MODE int Timer__tostring(lua_State* L) {
    co_timer_t* t = checkTimer(L1);
    pushS(L,(char*)t->ptr);
    return 1;
}

/****************************************************************/
/*! @class Process
 */
typedef int (*process_idsr_cb)(co_obj_t *self);
LqwCbKeyStrElem(ProcInitCB,Process,name)
LqwCbKeyStrElem(ProcDestroyCB,Process,name)
LqwCbKeyStrElem(ProcStopCB,Process,name)
LqwCbKeyStrElem(ProcRestartCB,Process,name)
#CallBack ProcInitCB{self} process_idsr_cb: N{_} @ Process{self}
#CallBack ProcDestroyCB{self} process_idsr_cb: N{_} @ Process{self}
#CallBack ProcStopCB{self} process_idsr_cb: N{_} @ Process{self}
#CallBack ProcRestartCB{self} process_idsr_cb: N{_} @ Process{self}

LqwCbKeyStrElem(ProcStartCB,Process,name)
#OwnCallBack ProcStartCB process_start_cb
static int callProcStartCB(co_obj_t *self, char *argv[]) {
    int i = 0;
    
    lqw_getCb(L,cbKeyProcStartCB((void*)self));
    pushProcess(L,self);
    pushT(L);
    
    for (;*(argv);argv++) {
        pushN(L,++i);
        pushS(L,*argv);
        lua_rawset(L, 3);
    }
    
    if(lua_pcall(L,2,1,0)) {
        //2do: Lua error
        return 0;
    } else {
        int r = toN(L,-1,int);
        lua_pop(L,1);
        return r;
    }
}

/** @constructor process.create(name, pid_file, exec_path, run_path, prof)  
  * @param prof a table for callbacks: init, destroy, start, stop, restart
  * all callbacks are passed the process object and return an integer (0 on success, else is fail)
  * start callback takes also a table of strings as second argument 
  */
#OwnFunction Process.create Process_create
LQW_MODE int Process_create(lua_State* L) {
    co_process_t proto = {
        {  CO_FLAG_LUAGC,NULL,NULL,0,_ext8 },
        _process, sizeof(co_process_t), 0, false, false, _STARTING,
        "LuaProc", "./pidfile", "./", "./", 0, 0,
        callProcInitCB, callProcDestroyCB, callProcStartCB, callProcStopCB, callProcRestartCB
    };

    lqwCbKey* cbKeys[] = {cbKeyProcInitCB,cbKeyProcDestroyCB,cbKeyProcStartCB,cbKeyProcStopCB,cbKeyProcRestartCB,NULL};
    co_process_t* p;

    proto.name = checkS(L,1);
    proto.pid_file = checkS(L,2);
    proto.exec_path = checkS(L,3);
    proto.run_path = checkS(L,4);
    lwqCheckCbsTbl(L,5,cbKeys);
    
    p = co_process_create(sizeof(lua_process), proto, proto.name, proto.pid_file, proto.exec_path, proto.run_path);
    
    if (p) {
        lwq_setCbsTbl(L,5,cbKeys,p);
        pushProcess(L,p);
        return 1;
    }
    
    return 0;
}

/** @method process.start(argv)
  * @param argv an optional table containing the string arguments (max 255) to the start procedure
  */
#OwnFunction Process.start
LQW_MODE int Process_start(lua_State* L) {
    co_obj_t *self = checkProcess(L1);
    char* argv[255];
    argv[0]=NULL;
    
    if (lua_type(L2) == LUA_TTABLE) {
        lua_pushnil(L);
        while (lua_next(L2) != 0) {
            if (i>255) break;
            argv[i] = toS(L, -1);
            lua_pop(L1);
            if (argv[i] == NULL) break;
            argv[++i] = NULL;
        }
        
        pushN(L,co_process_start(self,argv));
        return 1;
    }
    return 0;
}

/** @method process.__tostring()
  */
#Accessor Process.__tostring RO: S{lwcFmt("Process[%d] %s",$pid,$name)}


/*! @class Socket
 */

/** @method socket.add()
  */
Method Socket_add(lua_State*L) {
    co_obj_t *o = checkSocket(L1);
    int r = co_loop_add_socket(o, NULL);
    unmarkSocket(o);
    pushN(r);
    R1;
}

/** @method socket.remove()
  */
Method Socket_remove(lua_State*L) {
    co_obj_t *o = checkSocket(L1);
    int r = co_loop_remove_socket(o, NULL);
    markSocket(o);
    pushN(r);
    R1;
}


/** @constructror Socket.get(uri)
  */
Constructor Socket_get(lua_State*L) {
    char *uri = checkS(L,1);
    co_obj_t *o;
    
    if (( o = co_loop_get_socket(uri, NULL) )) {
        pushSocket(L,o);
        return 1;
    }
    
    return 0;
}

/** @constructror Socket.create(uri, listen, proto)
 * @brief creates a socket from specified values or initializes defaults
 * @param uri uri describing the socket
 * @param listen (defaults to FALSE) 
 * @param proto a table with the callbacks to be invoked
 * callback functions: 
 *  status_int = init(socket) 
 *  status_int = destroy(socket) 
 *  status_int = bind(socket,opt_ctx) 
 *  status_int = connect(socket,opt_ctx) 
 *  status_int = hangup(socket,opt_ctx)
 *  status_int = send(socket,data_buf)
 *  received_buf = receive(socket,fd_int)
 *  status_int = setopt(socket,level_int,option_id_int,optval_buf): 
 *  optval_buf = getopt(socket,level_int,option_id_int): 
 *  status_int = register(socket,opt_ctx): 
*/
LqwCbKeyStrElem(SocketInitCB,Socket,uri);
#CallBack SocketInitCB{self} co_socket_init_cb_t: N{_} @ Socket{self}

LqwCbKeyStrElem(SocketDestroyCB,Socket,uri);
#CallBack SocketDestroyCB{self} co_socket_destroy_cb_t: N{_} @ Socket{self}

LqwCbKeyStrElem(SocketHangUpCB,Socket,uri);
#CallBack SocketHangUpCB{self} co_socket_hangup_cb_t: N{_} @ Socket{self} U{context}

LqwCbKeyStrElem(SocketBindCB,Socket,uri);
#CallBack SocketBindCB{self} co_socket_bind_cb_t: N{_} @ Socket{self} S{endpoint}

LqwCbKeyStrElem(SocketConnectCB,Socket,uri);
#CallBack SocketConnectCB{self} co_socket_connect_cb_t: N{_} @ Socket{self} S{endpoint}

LqwCbKeyStrElem(SocketSendCB,Socket,uri);
#CallBack SocketSendCB{self} co_socket_send_cb_t: N{_} @ Socket{self} L{outgoing;length}

LqwCbKeyStrElem(SocketReceiveCB,Socket,uri);
#CallBack SocketReceiveCB{self} co_socket_receive_cb_t: L{incoming;_;65536} @ Socket{self} Fd{fd} X{length;65536}

LqwCbKeyStrElem(SocketSetOptCB,Socket,uri);
#Callback SocketSetOptCB{self} co_socket_setopt_bc_t: \
    N{_} @ Socket{self} N{level;int} N{option;int} L{optval;optvallen;void*;socklen_t}

LqwCbKeyStrElem(SocketGetOptCB,Socket,uri);
#CallBack SocketGetOptCB{self} co_socket_getopt_cb_t: \
   L{optval;_;65536} N{_} @ Socket{self} N{level;int} N{option;int} X{optvallen;65536;socklen_t}

LqwCbKeyStrElem(SocketPollCB,Socket,uri)
#CallBack SocketPollCB{self} co_socket_poll_cb_t: N{_} @ Socket{self} X{context}

LqwCbKeyStrElem(SocketRegisterCB,Socket,uri)
#CallBack SocketRegisterCB{self} co_socket_register_cb_t: N{_} @ Socket{self} U{context}

#OwnFunction Socket.create
LQW_MODE int Socket_create(lua_State* L){
    lqwCbKey* cbKeys[]* = {
        cbKeySocketInitCB,
        cbKeySocketDestroyCB,
        cbKeySocketHangUpCB,
        cbKeySocketBindCB,
        cbKeySocketConnectCB,
        cbKeySocketSendCB,
        cbKeySocketReceiveCB,
        cbKeySocketSetOptCB,
        cbKeySocketGetOptCB,
        cbKeySocketPollCB,
        cbKeySocketRegisterCB,
        NULL};
    Socket proto = {
        {COLUA_FLAGS,NULL,NULL,0,_ext8},_sock,sizeof(Socket),
        "URI",NULL,NULL,FALSE,NULL,NULL,FALSE,
        callSocketInitCB,
        callSocketDestroyCB,
        callSocketHangUpCB,
        callSocketBindCB,
        callSocketConnectCB,
        callSocketSendCB,
        callSocketReceiveCB,
        callSocketSetOptCB,
        callSocketGetOptCB,
        callSocketPollCB,
        callSocketRegisterCB,
        0
    };
    Socket* s;

    proto.uri = checkS(L,1);
    proto.listen = optB(L,2,FALSE);
    lwcCheckCbs(L,3,cbKeys);
    
    if((s = co_socket_create(sizeof(Socket), proto))) {
        lwcSetCbs(L,3,cbKeys,s);
        pushSocket(L,s);
        return 1;
    }
    
    return 0;
}

/** @fn Socket.init(socket)
 * @brief creates a socket from specified values or initializes defaults
 * @param size size of socket struct
 * @param proto socket protocol
 */
#Function Socket.init co_socket_init: N{_} @ Socket{self}

/** @fn Socket.destroy(socket)
 * @brief closes a socket and removes it from memory
 * @param socket 
 */
#Function Socket.destroy co_socket_destroy: N{_} @ Socket{self}

/** @fn Socket.hangup(socket)
 * @brief closes a socket and changes its state information
 * @param self socket name
 * @param context co_obj_t context pointer (currently unused)
 */
#Function Socket.hangup co_socket_hangup: N{_} @ Socket{self} X{context;NULL;void*}

/** @fn Socket.send(socket,data)
 * @brief sends a message on a specified socket
 * @param socket 
 * @param data message to be sent
 */
#Function Socket.send co_socket_send: N{_} @ Socket{self} L{outgoing;length}

/** @fn Socket.receive(socket)
 * @brief receives a message on the listening socket
 * @param socket
 */
#Function Socket.receive co_socket_receive: L{incoming;65536;_} N{_} @ Socket{self} X{lenght;65536;size_t}
int co_socket_receive(co_obj_t * self, co_obj_t *fd, char *incoming, size_t length);

/** @fn Socket.setopt(socket,level,option,optval)
 * @brief sets custom socket options, if specified by user
 * @param socket the socket
 * @param level the networking level to be customized
 * @param optval the value for the new option
 */
#Function Socket.setopt co_socket_setopt: N{_} @ Socket{self} N{level} N{option} L{optval;optvallen;void*;socklen_t}

/**
 * @brief gets custom socket options specified from the user
 * @param self socket name
 * @param level the networking level to be customized
 * @param option the option to be changed
 * @param optval the value for the new option
 * @param optvallen the length of the value for the new option
 */
#Function Socket.getopt co_socket_getopt: \
    L{optval;_;65536} N{_} @ Socket{self} N{level} N{option} X{optvallen;65536;socklen_t}

/**
 * @brief initializes a unix socket
 * @param self socket name
 */
#Function Socket.unix_init unix_socket_init: N{_} @ Socket{self}

/**
 * @brief binds a unix socket to a specified endpoint
 * @param self socket name
 * @param endpoint specified endpoint for socket (file path)
 */
#Function Socket.unix_bind unix_socket_bind: N{_} @ Socket{self} L{endpoint}

/**
 * @brief connects a socket to specified endpoint
 * @param self socket name
 * @param endpoint specified endpoint for socket (file path)
 */
#Function Socket.unix_connect unix_socket_connect: N{_} @ Socket{self} L{endpoint}

//2do profile.h
//2do tree.h
//2do util.h


/* Type "tree" declaration macros */
#define _DECLARE_TREE(L) typedef struct __attribute__((packed)) { co_obj_t _header; uint##L##_t _len; \
  _treenode_t *root;} co_tree##L##_t; int co_tree##L##_alloc(\
  co_obj_t *output); co_obj_t *co_tree##L##_create(void);



co_obj_t *co_node_key(_treenode_t *node);

co_obj_t *co_node_value(_treenode_t *node);

/**
 * @brief find node in given tree
 * @param root tree in which to search
 * @param key key to search for
 * @param klen length of key
 */
#Function Tree.find_node co_tree_find_node: \
    Str32{_->key} Obj{_->value} @ Tree{self} L{key;klen;size_t} X{root;self->root;_treenode_t *}

/**
 * @brief return root node of tree object
 * @param tree tree object that contains root
 */
#Function Tree.root co_tree_root: Str32{_->key} Obj{_->value} @ Tree{self}

/**
 * @brief return length (number of key-value pairs) of given tree
 * @param tree tree object
 */
#Function Tree.__length co_tree_length: L{_} @ Tree{tree}

/**
 * @brief return value from given tree that corresponds to key
 * @param root tree object
 * @param key key to search for
 * @param klen length of key
 */
#Function Tree.find co_tree_find: Obj{_} @ Tree{root} L{key;klen;size_t}

/**
 * @brief delete value from given tree that corresponds to key
 * @param root tree object
 * @param key key to search for
 * @param klen length of key
 */
#Function Tree.delete co_tree_delete: Obj{_} @ Tree{root} L{key;klen;size_t}

/**
 * @brief insert object into given tree and associate with key
 * @param root tree object
 * @param key key to search for
 * @param klen length of key
 * @param value value object to insert
 */
#Function Tree.insert co_tree_insert: N{_} @ Tree{root} L{key;klen} Obj{value}

/**
 * @brief set value contained in an object in the tree with a specified key (if a string)
 * @param root tree object
 * @param key key to search for
 * @param klen length of key
 * @param value value to insert
 * @param vlen length of value
 */
#Function Tree.set_str co_tree_set_str: N{_} @ Tree{root} L{key;klen} L{value;vlen}

/**
 * @brief set value contained in an object in the tree with a specified key (if an int)
 * @param root tree object
 * @param key key to search for
 * @param klen length of key
 * @param value value to insert
 */
#Function Tree.set_int co_tree_set_int: N{_} @ Tree{root} L{key;klen} N{value;signed long}

/**
 * @brief set value contained in an object in the tree with a specified key (if an unsigned int)
 * @param root tree object
 * @param key key to search for
 * @param klen length of key
 * @param value value to insert
 */
#Function Tree.set_uint co_tree_set_uint: N{_} @ Tree{root} L{key;klen} N{value;unsigned long}

/**
 * @brief set value contained in an object in the tree with a specified key (if a float)
 * @param root tree object
 * @param key key to search for
 * @param klen length of key
 * @param value value to insert
 */
#Function Tree.set_float co_tree_set_float: N{_} @ Tree{root} L{key;klen} N{value;double}

/**
 * @brief process tree with given iterator function
 * @param tree tree object to process
 * @param iter iterator function
 * @param context additional arguments to iterator
 */
#Function Tree.__call co_tree_process: Obj{_} @ Tree{tree} ListIter{iter} X{context;NULL}


/**
 * @brief free tree structure
 * @param root tree object to free
 */
//void co_tree_destroy(co_obj_t *root);
//2do GC

/**
 * @brief dump raw representation of tree
 * @param output output buffer
 * @param olen length of output buffer
 * @param tree tree to dump
 */
Function Tree.__tostring co_tree_raw: L{output;_;256000} N{_} @ Tree{tree} X{olen;256000;size_t}

/**
 * @brief import raw representation of tree
 * @param tree target pointer of new, imported tree object
 * @param input input buffer
 * @param ilen length of input buffer
 */
#Function Tree.import co_tree_import: Tree{out} N{_} @ L{input;ilen} X{tree;&out;Obj**}



/** @fn Node.plugins_load(dir_path)
 * @brief loads all plugins in specified path
 * @param dir_path directory to load plugins from
 */
#Function Node.plugins_load co_plugins_load: N{_} @ S{dir_path}

LqwRealoc2lua_Alloc(colua_alloc,h_realloc,h_free);
    
static void init_globals(lua_State* L) {
    nil_obj = co_nil_create(0);
    lqwInit(colua_alloc,NULL);
}

#Finish co_lua_register
